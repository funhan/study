# Datastructure

* [선형구조]
  * Array
  * Linked list
  * Stack
  * Queue
  
* [비선형구조]
  * Tree
  * Graph
  
</br>

## Array vs LinkedList

### Array

가장 기본적인 자료구조인 'Array'는 논리적 저장 순서와 물리적 저장 순서가 일치한다. 따라서 인덱스로 해당 원소에 접근이 가능하다. 그렇기 때문에 찾고자 하는 원소의 인덱스 값을 알고 있으면 'O(1)'만에 해당 원소로 접근할 수 있다. 즉, Random Access가 가능하다.
   
   하지만 삭제 또는 삽입 과정에서 해당 원소에 접근하여 작업을 완료한 뒤('O(1)'), Shift를 해주는 작업을 추가적으로 해줘야 하기 때문에, 시간이 더 걸린다. 만약 배열의 원소 중 어느 원소를 삭제했다고 했을 때, 배열의 연속적인 특징이 깨지게 된다. 즉 빈 공간이 생기는 것이다. 따라서 삭제한 원소보다 큰 인덱스를 갖는 원소들을 Shift해줘야 하는 비용(Cost)이 발생하고 이 경우의 시간 복잡도는 'O(n)'이 된다. 그렇기 때문에 Array 자료구조에서 삭제  기능에 대한 시간복잡도의 worst case는 'O(n)'이 된다. 삽입의 경우도 마찬가지이다. 만약 첫번째 자리에 새로운 원소를 추가하고자 한다면, 모든 원소들의 인덱스를 1씩 Shift해줘야 하므로 이 경우도 'O(n)'의 시간복잡도를 가진다.
   
### LinkedList

'Array'의 문제점을 해결하기 위한 자료구조이다. 'LinkedList'는 자료의 주소 값으로 노드를 이용해 서로 연결되어 있는 구조를 갖는다. 각각의 원소들은 자기 자신 다음에 어떤 원소인지만을 기억하고 있다. 따라서 이 부분만 다른 값으로 바꿔주면 삭제와 삽입을 'O(1)'만에 수행할 수 있다.

하지만 원하는 위치에 삽입을 하고자 한다면, 원하는 위치를 'Search'하는 과정에 있어서 첫번째 원소부터 일일이 확인해봐야 한다. Array와 달리 논리적 저장 순서와 물리적 저장 순서가 일치하지 않기 때문이다. 따라서 어떤 원소를 삭제 또는 삽입할 때, 그 원소를 찾기 위해서 'O(n)'의 시간이 추가적으로 발생하게 된다.

따라서 LinkedList는 탐색, 삽입, 삭제에 대해서 'O(n)'의 시간복잡도는 갖는다. 하지만 이 자료구조는 'Tree' 구조의 근간이 되는 자료구조이므로 중요하다.

#### 결론

데이터 접근 속도는 Array가 Random Access가 가능하므로 'O(1)'이고, LinkedList는 순차 접근으로 'O(n)'이다. 따라서 Array가 LinkedList보다 더 빠르다.

데이터 삽입 속도는 Array, LinkedList 모두 'O(n)'이지만, Array의 경우 삽입하기 위해 데이터를 Shift하는 과정이 필요하므로 데이터가 많을 경우 비효율적이다. LinkedList는 삽입할 위치를 찾고('O(n)') 삽입을 하기 때문에, Array보다 빠르다. 삭제의 경우도 동일하다.

따라서 삽입/삭제가 빈번하다면 LinkedList를 사용하는 것이 좋고, 데이터의 접근이 중요하다면 Array를 사용하는 것이 좋다.

</br>

## Stack, Queue

### Stack

'Last In First Out (LIFO)'. 즉, 나중에 들어간 원소가 먼저 나오는 구조이다. 차곡차곡 쌓이는 구조로 먼저 Stack에 들어가게 된 원소는 맨 바닥에 깔리게 된다. 그렇기 때문에 늦게 들어간 원소는 그 위에 쌓이게 되고 호출 시 가장 위에 있는 원소가 호출되는 구조이다.

### Queue

'First In First Out (FIFO)'. 즉, 먼저 들어간 원소가 먼저 나오는 구조이다. Stack과는 반대로 먼저 들어간 원소가 맨 앞에서 대기하고 있다가 먼저 나오게 되는 구조이다. 

</br>

## Tree

Tree는 비선형 자료구조이며, 계층적 관계(Hierarchical Relationship)을 표현하는 자료구조이다. 

#### Tree를 구성하고 있는 구성요소들

* Node (노드) : 트리를 구성하고 있는 각각의 요소를 의미한다.
* Edge (간선) : 트리를 구성하기 위해 노드와 노드를 연결하는 선을 의미한다.
* Root Node (루트 노드) : 트리 구조에서 최상위에 있는 노드를 의미한다.
* Leaf Node ( = Terminal Node, 단말 노드) : 하위에 다른 노드가 연결되어 있지 않은 노드를 의미한다.
* Internal Node (내부노드, 비단말 노드) : 단말 노드를 제외한 모든 노드로 루트 노드를 포함한다.




