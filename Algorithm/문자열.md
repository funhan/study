# 문자열 검색 알고리즘

주어진 긴 '짚더미' 문자열 H가 '바늘' 문자열 N을 부분 문자열로 포함하는지 확인하고, 포함한다면 N과 일치하는 부분 문자열의 시작 위치를 찾는 문제를 문자열 검색 문제라고 한다.

## KMP 알고리즘

문자열 검색시 불필요한 문자간 비교를 없애기 위해 실패 함수를 사용하여, 문자열 검색시 일치하지 않는 문자가 있을때 지금까지 일치한 결과를 이용하여 다음으로 시도해야할 시작 위치를 빠르게 찾아내는 알고리즘이다.

getPartialMatch 함수의 시간복잡도 = O(N)
kmpSearch 함수의 시간복잡도 = O(H)

따라서 전체 시간복잡도 = O(N + H)


### 실패 함수(부분 일치 테이블, pi) 계산 코드


// N에서 자기 자신을 찾으면서 나타나는 부분 일치를 이용해 pi[] 계산
// pi[i] = N[..i]의 접미사도 되고 접두사도 되는 문자열의 최대 길이
vector<int> getPartailMatch(const string& N)
{
	int m = N.size();
	vector<int> pi(m, 0);
	// KMP로 자기 자신을 찾는다.
	// N을 N에서 찾는다. begin = 0이면 자기 자신을 찾아버리기 때문에 1부터 시작.
	int begin = 1, matched = 0;
	
	// 비교할 문자가 N의 끝에 도달할 때까지 찾으면서 부분 일치를 모두 저장.
	while(begin + matched < m) {
		if(N[begin + matched] == N[matched]) {
			++matched;
			pi[begin + matched - 1] = matched;
		}
		else {
			if(matched == 0) ++begin;
			else {
				begin += matched - pi[matched - 1];
				matched = pi[matched - 1];
			}
		}
	}
	return pi;
}

vector<int> getPartialMatch2(const string& N)
{
	int m = N.size();
	vector<int> pi(m, 0);
	
	int matched = 0;
	for(int i = 1; i < m; ++i) {
		while(matched > 0 && N[i] != N[matched])
			matched = pi[matched - 1];
		
		if(N[i] == N[matched]) {
			++matched;
			pi[i] = matched;
		}

	}
	return pi;
}


### KMP 문자열 검색 알고리즘 코드

// '짚더미' H의 부분 문자열로 '바늘' N이 출현하는 시작 위치들을 모두 반환한다.
vector<int> kmpSearch(const string& H, const string& N) 
{
	int n = H.size(), m = N.size();
	vector<int> ret;
	// pi[i] = N[..i]의 접미사도 되고 접두사도 되는 문자열의 최대 길이	vector<int> pi = getPartialMatch(N);
	
	// begin = matched = 0에서 시작
	int begin = 0, matched = 0;
	
	while(begin <= n - m) {
		// 만약 짚더미의 해당 글자가 바늘의 해당 글자와 같다면
		if(matched < m && H[begin + matched] == N[matched]) {
			++matched;
			// 결과적으로 m 글자가 모두 일치했으면 답에 추가
			if(matched == m) ret.push_back(begin);
		}
		else {
			// 예외 : matched가 0인 경우에는 다음 칸에서 시작
			if(matched == 0) ++begin;
			else {
				begin += matched - pi[matched - 1];
				// begin을 옮겼다고 처음부터 다시 비교할 필요가 없음.				// 옮긴 후에서 pi[matched -1] 만큼 일치하기 때문
				matched = pi[matched - 1];
			}
		}
	}
	return ret;
}

vector<int> kmpSearch2(const string& H, const string& N)
{
	int n = H.size(), m = N.size();
	vector<int> ret;
	vector<int> pi = getPartialMatch(N);
	// 현재 대응된 글자의 수
	int matched = 0;
	for(int i = 0; i < n; ++i) {
		// matched번 글자와 짚더미의 해당 글자가 불일치할 경우
		// 현재 대응된 글자의 수를  pi[matched - 1]로 줄인다.
		while(matched > 0 && H[i] != N[matched])
			matched = pi[matched - 1];
	
		if(H[i] == N[matched]) {
			++matched;
			if(matched == m) {
				ret.push_back(i - m + 1);
				matched = pi[matched - 1];
			}
		}
	}
	return ret;
}






























