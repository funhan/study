# 부분 합

배열의 각 위치에 대해 배열의 시작부터 현재 위치까지의 원소의 합을 구해 둔 배열.  
이를 사용하면 배열의 특정 구간의 합을 `O(1)`에 구할 수 있음.  

## 부분 합 계산 코드

```cpp
// 주어진 벡터 a의 부분 합 계산
vector<int> partialSum(const vector<int>& a) {
	vector<int> ret(a.size());
	ret[0] = a[0];
	for(int i=1;i<a.size();++i) 
		ret[i] = ret[i-1] + a[i];
	return ret;
}

// 부분 합 psum[]이 주어질 때, 원래 벡터의 a부터 b까지의 합
int rangeSum(const vector<int>& psum, int a, int b) {
	if(a == 0)return psum[b];
	return psum[b] - psum[a-1];
}
```

# 구간 트리

일차원 배열의 특정 구간에 대한 질문을 빠르게 대답하는데 사용.

기본적인 아이디어는 주어진 배열의 구간들을 표현하는 이진 트리를 생성. 이때, 구간 트리의 루트는 항상 배열의 전체 구간 [0, n-1]을 표현하며, 한 트리의 왼쪽과 오른쪽 자식은 각각 해당 구간의 왼쪽 반과 오른쪽 반을 표현함. 길이가 1인 구간을 표현하는 노드는 구간 트리의 리프임. 따라서 어떤 구간이 주어지더라도 답을 찾기 위해 고려해야 하는 구간의 수는 O(logn).

## 구간 최소 쿼리(range minimum query, RMQ)

특간 구간의 최소치를 찾는 문제를 말함. 

구간 트리는 비교적 '꽉 찬' 이진 트리임. 따라서 배열로 트리를 나타냄. 이때, 배열의 길이는 n이 2의 거듭제곱이라면 2n이면 되지만, 아닐 경우 가까운 2의 거듭제곱으로 n을 올림한 뒤 2를 곱해야 함. 그래서 메모리를 낭비하는 단점이 있지만, 그냥 n에 4를 곱하여 4n의 길이만큼 설정함.  

### 구간 최소 쿼리 구간 트리 코드

```cpp
//배열의 구간 최소 쿼리를 해결하기 위한 구간 트리 구현
struct RMQ {
	// 배열의 길이
	int n;
	// 각 구간의 최소치
	vector<int> rangeMin;
	RMQ(const vector<int>& array) {
		n = array.size();
		rangeMin.resize(4 * n);
		init(array, 0, n-1, 1);
	}
	// 노드가 array[left, right] 배열을 표현할 때,
	// 노드를 루트로 하는 서브트리를 초기화하고, 이 구간의 최소치를 반환.
	int init(const vector<int>& array, int left, int right, int node) {
		if(left == right)
			return rangeMin[node] = array[left];
		int mid = (left + right) / 2;
		int leftMin = init(array, left, mid, node * 2);
		int rightMin = init(array, mid + 1, right, node * 2 + 1);
		return rangeMin[node] = min(leftMin, rightMin);
	}
	// node가 표현하는 범위 array[nodeLeft, nodeRight]가 주어질 때
	// 이 범위와 array[left, right]의 교집합의 최소치를 구함.
	int query(int left, int right, int node, 
					int nodeLeft, int nodeRight) {
		// 두 구간이 겹치지 않으면 아주 큰 값을 반환 : 무시됨
		if(right < nodeLeft || nodeRight < left) return INT_MAX;
		// node가 표현하는 범위가 array[left, right]에 완전히 포함되는 경우
		if(left <= nodeLeft && nodeRight <= Right)
			return rangeMin[node];
		// 양쪽 구간을 나눠서 푼 뒤 결과를 합침.
		int mid = (nodeLeft + nodeRight) / 2;
		return min(query(left, right, node*2, nodeLeft, mid), 
						query(left, right, node*2+1, mid+1, nodeRight));
	}
	// query()를 외부에서 호출하기 위한 인터페이스
	int query(int left, int right) {
		return query(left, right, 1, 0, n-1);
	}

	// arry[index]=newValue로 바뀌었을 때 node를 루트로 하는 구간트리를 갱신하고
	// 노드가 표현하는 구간의 최소치를 반환.
	int update(int index, int newValue, 
					int node, int nodeLeft, int nodeRight) {
		// index가 노드가 표현하는 구간과 상관없는 경우 무시.
		if(index < nodeLeft || nodeRight < index)			return rangeMin[node];
		// 트리의 리프까지 내려온 경우
		if(nodeLeft == nodeRight) return rangeMin[node] = newValue;
		int mid = (nodeLeft + nodeRight) / 2;
		return rangeMin[node] = min(
				update(index, newValue, node*2, nodeLeft, mid),
				update(index, newValue, node*2+1, mid+1, nodeRight));
	}
	// update()를 외부에서 호출하기 위한 인터페이스
	int update(int index, int newValue) {
		return update(index, newValue, 1, 0, n-1);
	}
};

```










